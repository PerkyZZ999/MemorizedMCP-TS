<!-- 7315e758-f3e1-442b-96bb-767c4ff13b1d ca9db6f8-9f42-4f82-9f51-95943f9d6850 -->
# MemorizedMCP-TS Development Roadmap

## Phase 0 – Project Bootstrap (Week 0)

- Initialize Bun workspace (`bun init`), configure `package.json` scripts, and set `bunfig.toml` to use ESM modules.
- Install baseline dependencies: `@modelcontextprotocol/sdk`, `zod`, `zod-to-json-schema`, `pino`, `node-cron`, `dotenv`, `typescript`, `vitest`, `biome` (or eslint), and types packages.
- Create foundational directory structure:
- `src/config/`: configuration loader & schema.
- `src/logging/`: Pino setup.
- `src/schemas/`: Zod definitions and JSON Schema generation utilities.
- `src/services/`, `src/repositories/`, `src/vector/`, `src/jobs/`, `src/server/`.
- Stub entrypoint `src/index.ts` to load config, initialize logging, and print readiness banner.
- Implement `ConfigSchema` (Zod) and loader that merges defaults, `.env`, and runtime overrides; add tests.
- Add npm scripts: `bun dev`, `bun build`, `bun lint`, `bun test`, `bun generate-schemas`.
- Document setup instructions in README (dependencies, environment variables, commands).

## Phase 1 – Data Foundations (Weeks 1–2)

- Draft SQL migrations under `sql/migrations/` to create tables/indices/FTS5 virtual tables noted in `docs/Data-Model.md`.
- Build migration runner (`src/scripts/migrate.ts`) and integrate with `bun run migrate`.
- Implement SQLite connection manager (`src/database/sqlite.ts`) enabling WAL, busy timeout, foreign keys, and telemetry hooks.
- Implement repositories with typed methods and tests:
- `MemoryRepository`, `DocumentRepository`, `DocumentChunkRepository`, `KnowledgeGraphRepository`, `TagRepository`, `AnalyticsRepository`, `JobRepository`.
- Integrate Vectra via adapter module (`src/vector/vectra.ts`): initialize collections, define insert/query/update helpers, provide health check.
- Create repository unit tests using temporary SQLite databases and mocked Vectra storage.
- Establish shared error types and transaction helpers to be consumed by services.

## Phase 2 – Service Layer Implementation (Weeks 3–4)

- **DocumentService**: implement ingestion pipeline (file/content → unpdf → chunking → embeddings via Transformers.js → persistence), retrieval, analysis, reference validation.
- **MemoryService**: handle add/search/update/delete, layer transitions (STM/LTM), importance scoring, consolidation stubs, reference management.
- **KnowledgeGraphService**: integrate compromise NLP for entity extraction, manage entity CRUD, relations, tagging, and lists/search.
- **SearchService**: orchestrate hybrid retrieval combining Vectra similarity, FTS5 relevance, KG boosts, caching, and filters.
- **AnalyticsService/SystemService**: initial implementations for metrics aggregation, status reporting, backup hooks.
- Ensure service methods return typed DTOs derived from Zod schemas; add targeted service tests.

## Phase 3 – MCP Interface & Tooling (Weeks 5–6)

- Implement MCP server wrapper (`src/server/mcp.ts`) using `@modelcontextprotocol/sdk` stdio transport.
- Build single-tool sandbox:
- TypeScript VM execution (Bun runtime), binding injection for generated clients, timeout & resource guard rails, result serialization.
- Error propagation mapping to MCP error structures.
- Implement multi-tool registry toggle (respect `MCP_MULTI_TOOL` env), reusing service methods and schemas.
- Build schema/code generation pipeline:
- Generate JSON Schema files from Zod definitions (`bun run generate-schemas`).
- Produce client namespace definitions for sandbox ingestion (auto-doc strings, JSDoc comments).
- Expose server instructions endpoint describing workflows, sandbox limitations, and fallback usage.
- Provide sample prompts/resources for downstream hosts (optional `resources/` directory).

## Phase 4 – Background Jobs & Operational Utilities (Weeks 7–8)

- Implement scheduler (`src/jobs/scheduler.ts`) registering consolidation, cleanup, backup, reindex, metrics rollup jobs with cron expressions from env.
- Build backup/restore scripts (`scripts/backup.ts`, `scripts/restore.ts`) and integrate with `system.backup/system.restore` tools.
- Implement data export/import utilities for partial datasets (e.g., JSONL export of memories, docs).
- Enhance logging with request IDs, tool context, latency metrics; support optional file sink.
- Add metrics aggregation stubs (preparing for Prometheus) capturing query timings and job outcomes.

## Phase 5 – Testing, Performance & Hardening (Weeks 9–10)

- Develop integration test suite using Vitest for end-to-end flows under single-tool and multi-tool modes.
- Create performance benchmark scripts measuring ingestion throughput and search latency; tune Vectra and SQLite parameters accordingly.
- Build migration script `scripts/import-rust-data.ts` to translate sled/tantivy exports into SQLite/Vectra; include verification checks.
- Conduct security review: sandbox restrictions, path sanitization, config exposure, backup integrity.
- Update documentation with troubleshooting, performance tuning, and migration guidance based on findings.

## Phase 6 – Release Preparation (Week 11)

- Finalize README (installation, configuration, quickstart, migration steps) referencing the spec documents.
- Compile CHANGELOG and end-user migration guide covering differences from Rust server.
- Produce distributable artifacts: `dist/` build, sample `.env`, cron templates, optional Docker/systemd examples.
- Execute final acceptance tests, confirm job schedules, and tag release `v1.0.0-beta` with release notes.